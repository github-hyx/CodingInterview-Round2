# 15-二进制中1的个数

[OJ链接](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

**题目描述**

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

**思路分析**

**方法一：**
首先把n和1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算...（循环次数等于整数二进制的位数。unsigned int flag = 1）

注意：
* 正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。
* 负数的右移，先计算补码，补码移位，在高位补1,按位取反后再加1即可。

**方法二：**
一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数二进制表示中最右边的1变成0；（有多少个1就循环多少次）

**代码实现（方法一）**

```c++
class Solution 
{
public:
     int  NumberOf1(int n) 
     {
         int count=0;
         unsigned int flag=1;
         while(flag)
         {
             if(n&flag)
                 count++;
             flag=flag<<1;
         }
         return count;
     }
};
```

**代码实现（方法二）**

分析一下代码： 这段小小的代码，很是巧妙。如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，
原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。

举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，
因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。
这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.

也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

```c++
class Solution 
{
public:
     int  NumberOf1(int n) 
     {
         int count=0;
         while(n)
         {
             ++count;
             n=n&(n-1);
         }
         return count;
     }
};
```

**总结**

* 这题不熟练

**负数的右移**

                   举例1：
                   -100带符号右移4位。

                   -100原码：   10000000    00000000    00000000   01100100

                   -100补码：    保证符号位不变，其余位置取反加1

                                         11111111    11111111    11111111   10011100

                   右移4位： 在高位补1

                                         11111111    11111111    11111111    11111001

                   补码形式的移位完成后，结果不是移位后的结果，要根据补码写出原码才是我们所求的结果。其方法如下:

                   保留符号位，然后按位取反：

                                         10000000    00000000    00000000     00000110

                    然后加1，即为所求数的原码：

                                                   10000000    00000000    00000000    00000111

                         所有结果为：-7

                  举例2：

                            -100无符号右移4位。

                   -100原码：   10000000    00000000    00000000   01100100

                   -100补码：    保证符号位不变，其余位置取反加1

                                         11111111    11111111    11111111   10011100

                   无符号右移4位： 在高位补0

                                         00001111    11111111    11111111    11111001

                  即为所求：268435449

