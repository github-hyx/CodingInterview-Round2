# 03-数组中重复的数字

[OJ链接](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

**题目描述**

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

**思路分析**



**代码实现1**

```c++
class Solution {
public:
    void Permutation(string& str,int index,vector<string>& res){
        int size=str.size();
        if(index==size-1)
            res.push_back(str);
        for(int i=index;i<size;i++){
            if(i!=index&&str[i]==str[index])
                continue;
            swap(str[i],str[index]);
            Permutation(str,index+1,res);
            swap(str[i],str[index]);
        }
    }
    vector<string> Permutation(string str) {
        vector<string> res;
        if(str.size()==0)
            return res;
        Permutation(str,0,res);
        sort(res.begin(),res.end());
        return res;
    }
};
```

**代码实现2（利用set判断是否遇到相同字符）**

```c++
class Solution {
public:
    vector<string> Permutation(string str) {
        vector<string> res;
        if(str.size() == 0)
            return res;
        
        Permutation(str,0,res);
        //为了按字典序输出，需要排序
        sort(res.begin(),res.end());
        return res;
    }
    
    void Permutation(string &s,int idx,vector<string> &res){
        int sz = s.size();
        if(idx == (sz - 1)){
            res.push_back(s);
            return;
        }
        
        set<char> swaped;//为了处理相同的字符
        for(int i = idx;i < sz;i++){
            char c = s[i];
            //说明遇到了相同的字符
            if(swaped.find(c) != swaped.end()){
                continue;
            }
            swaped.insert(c);
            s[i] = s[idx];
            s[idx] = c;
            
            Permutation(s,idx+1,res);
            
            s[idx] = s[i];
            s[i] = c;
        }
    }
};
```
**总结**

* 注意检查判断空字符串是if(str.size()==0)不是nullptr
* 输入参数为string& str就必须要交换回来，要回溯之前状态；输入参数为string str时，可以不交换回来，因为递归返回时原str没有被改变

